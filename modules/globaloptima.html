<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>EVT (Global Optima)</title>
  <script src="js/mathbox-bundle.js"></script>
  <script src="js/dat.gui.js"></script>

  <!-- http://silentmatt.com/javascript-expression-evaluator/ -->
  <script src="js/parser.js"></script>

  <!-- https://mathjs.org/ -->
  <script src="js/math.js"></script>

  <link rel="stylesheet" href="css/mathbox.css">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <style>
	#bgcolor {
		height: 97vh;
		background: rgb(22,73,125);
		background: linear-gradient(90deg, rgba(22,73,125,1) 0%, rgba(11,11,38,1) 50%, rgba(22,73,125,1) 100%);
		align: center;
	}
</style>
</head>
<body>
<div id="bgcolor"></div>

<script>

	<!-- START OF SCENE SETUP ==================================================================== -->
	// includes mathbox VR setup, axes, and graph color settings
	
	var element =  document.querySelector('#bgcolor'); //place the graph within custom Div
	
	var mathbox = mathBox({ element: element,
      plugins: ['VR', 'ui', 'controls'],
      controls: {
        klass: THREE.VRControls
      },
    });
    if (mathbox.fallback) throw "WebGL not supported"
	
	// setting proxy:true allows interactive controls to override base position
	var camera = mathbox.camera( { proxy: true, position: [4,2,4] } );
	
    // set the boundaries/scale of the graph display
	// zMin & zMax values are just placeholder, they would be replaced in later function if autofit is true
	var	xMin = -5, xMax = 5, yMin = -5,	yMax = 5, zMin = -10, zMax = 10;
	
	// set the display view with mathbox
	// note that by default, mathbox y & z axis references are switched,
	// so remember to always use [x,z,y] instead of [x,y,z] in the code
    var view = mathbox.cartesian(
	  {
        range: [[xMin, xMax], [yMin, yMax], [zMin,zMax]],
		//scale for y axis should be negative since original mathbox yAxis (on z) is flipped
        scale: [2,1,-2],
      }
	);

	<!-- Axis settings -->
	var xAxis = view.axis( {axis: 1, width: 8, detail: 40, color:"deeppink"} );
    var xScale = view.scale( {axis: 1, divide: xMax, nice:true, zero:true} );
    var xTicks = view.ticks( {width: 5, size: 15, color: "deeppink", zBias:2} );
    var xFormat = view.format( {digits: 2, font:"Helvetica", style: "normal", source: xScale} );
    var xTicksLabel = view.label( {color: "deeppink", zIndex: 0, offset:[0,-20], outline: 0, size: 14, points: xScale, text: xFormat} );
	
	var yAxis = view.axis( {axis: 3, width: 8, detail: 40, color:"greenyellow"} );
    var yScale = view.scale( {axis: 3, divide: yMax, nice:true, zero:false} );
    var yTicks = view.ticks( {width: 5, size: 15, color: "greenyellow", zBias:2} );
    var yFormat = view.format( {digits: 2, font:"Helvetica", style: "normal", source: yScale} );
    var yTicksLabel = view.label( {color: "greenyellow", zIndex: 0, offset:[-20,0], outline: 0, size: 14, points: yScale, text: yFormat} );
	
	var zAxis = view.axis( {axis: 2, width: 8, detail: 40, color:"cyan"} );
    var zScale = view.scale( {axis: 2, divide: zMax, nice:true, zero:false} );
    var zTicks = view.ticks( {width: 5, size: 15, color: "cyan", zBias:2} );
    var zFormat = view.format( {digits: 2, font:"Helvetica", style: "normal", source: zScale} );
    var zTicksLabel = view.label( {color: "cyan", zIndex: 0, offset:[20,0], outline: 0, size: 14, points: zScale, text: zFormat} );
	
	// axis end labels
	var xLabelText = view.text( {width:1, data:["x"], font: "Helvetica", style: "normal"} );
	var xLabelPoint = view.array( {width:1, channels:3, data:[ [xMax,0,0] ]} );
	var xLabelDisplay = view.label( {text: xLabelText, points: xLabelPoint,
      size: 18, color: "deeppink", outline: 0, offset: [20, 10], zIndex: 1} );
	  
	var yLabelText = view.text( {width:1, data:["y"], font: "Helvetica", style: "normal"} );
	var yLabelPoint = view.array( {width:1, channels:3, data:[ [0,0,yMax] ]} );
	var yLabelDisplay = view.label( {text: yLabelText, points: yLabelPoint,
      size: 18, color: "greenyellow", outline: 0, offset: [-10, 20], zIndex: 1} );
	  
	// view semi-transparent grid at z=0
	view.grid( {axes:[1,3], width: 2, divideX: 20, divideY: 20, opacity:0.25} );
	
	 
	<!-- graph Color setting -->
	var graphData = view.area({
		axes: [1,3], channels: 3, width: 64, height: 64,
        expr: function (emit, x, y, i, j, t)
		{
		  var z = x*y;
          emit( x, z, y );
        },
    });
	
	// actual emitter set in displayGraph function
	var graphColors = view.area({
		expr: function (emit, x,y, i,j, t) 
		{
			if (x < 0)
				emit(1.0, 0.0, 0.0, 1.0);
		    else
				emit(0.0, 1.0, 0.0, 1.0);
		},
		axes: [1,3],
		width:  64, height: 64,
		channels: 4, // RGBA
    });
	
	var graphViewSolid = view.surface({
		points:graphData, 
		color:"#FFFFFF", shaded:false, fill:true, lineX:false, lineY:false, colors:graphColors, visible:true, width:0
	});
	
	<!-- END OF SCENE SETUP ============================================================= -->
	
	<!-- START OF DISPLAY GRAPH SETTING ==================================================== -->
	// to display the basic graph
	 
	var functionText = "x^2+x*y"; // the function to parse
	
	var zAutofit = true; 
	
	var critPointsArray = [];
	
	var displayGraphFunc = function() 
	{ 
		var f = Parser.parse( functionText ).toJSFunction( ['x','y'] );
		graphData.set("expr", 
		    function (emit, x, y, i, j, time) 
			{ 
			    emit( x, f(x,y), y );
			}
		);
		
		//autofit the scale of the graph so it fits to the screen nicely
		if (zAutofit)
		{
			var xStep = (xMax - xMin) / 256;
			var yStep = (yMax - yMin) / 256;
			var zSmallest = f(xMin, yMin);
			var zBiggest  = f(xMax, yMax);
			
			//for every possible x & combination, find the smallest & biggest z values
			//infinity check is a must, otherwise when the equation results in infinity (ie divide by zero) then the graph cannot be plotted
			//when the z value is infinite, we can assign our own value to scale the graph nicely (this is optional) 
			for (var x = xMin; x <= xMax; x += xStep)
			{
				for (var y = yMin; y <= yMax; y += yStep)
				{
					var z = f(x,y);
					if (z <= zSmallest && isFinite(z) == true){
						zSmallest = z;
					} else if (z <= zSmallest && isFinite(z) == false){ //optional
						zSmallest = -256; //it can be any number since it's infinite
					}
					
					if (z >= zBiggest && isFinite(z) == true) {
						zBiggest = z;
					} else if (z >= zBiggest && isFinite(z) == false){ //optional
						zBiggest = 256; //it can be any number since it's infinite
					}
				}
			}
			
			// change the global zMin var value to follow the smallest possible z val and
			// global zMax var value to follow the biggest possible z val
			zMin = zSmallest;
			zMax = zBiggest;
		}
		
	
		view.set("range", [[xMin, xMax], [zMin,zMax], [yMin, yMax]]); 
		
		//set the graph color to rainbow that dynamically changes with value
		//use HSL so it's easier to scale (use percent) instead of RGB
		graphColors.set("expr",
				function (emit, x, y, i, j, t)
				{
					var z = f(x,y);
					var percent = (z - zMin) / (zMax - zMin);
					emit( percent, percent, percent, 0.8 );
				}
			);
		
	
		displayRangeFunc();
		
		//reset the points data/array whenever the graph is updated with new equation
		critPointsDispArray = [];
		critPointData.set("data", critPointsDispArray);
		
		globalMaximaArray = [];
		globalMaximaData.set("data",[globalMaximaArray]);
		
		globalMinimaArray = [];
		globalMinimaData.set("data",[globalMinimaArray]);
		

		displayTraceFunc();
		
		
	}
	<!-- END OF DISPLAY GRAPH SETTING ===================================================== -->
	
	
	<!-- START OF CURVE (RANGE DOMAIN) DISPLAY  ==================================================== -->
	
	var lowerXRange = -2, upperXRange = 2, lowerYRange = -2, upperYRange = 2; 
	
	var displayRangeFunc = function()
	{
		f = Parser.parse( functionText ).toJSFunction( ['x','y'] );
		
		xMinCurveData.set("expr", 
		    function (emit, y, j, t) 
			{ 
			    emit( lowerXRange, f(lowerXRange,y), y );
			}
		);
		xMinCurveText.set("data", ["xMin = " + Math.round(lowerXRange * 100) / 100]);

		xMaxCurveData.set("expr", 
		    function (emit, y, j, t) 
			{ 
			    emit( upperXRange, f(upperXRange,y), y );
			}
		);
		xMaxCurveText.set("data", ["xMax = " + Math.round(upperXRange * 100) / 100]);
		
		yMinCurveData.set("expr", 
		    function (emit, x, i, t) 
			{ 
			    emit( x, f(x,lowerYRange), lowerYRange );
			}
		);
		yMinCurveText.set("data", ["yMin = " + Math.round(lowerYRange * 100) / 100]);
		
		yMaxCurveData.set("expr", 
		    function (emit, x, i, t) 
			{ 
			    emit( x, f(x,upperYRange), upperYRange );
			}
		);
		yMaxCurveText.set("data", ["yMax = " + Math.round(upperYRange * 100) / 100]);
		
		
		
		
		
		
	}
	
	// plot curves (boundaries) on graph  

	var xMinCurveData = view.interval({
		axis: 3, channels: 3, width: 64,
	});
	var xMinCurveView = view.line({
		points: xMinCurveData,
		color: "lightgreen", width: 16, visible: true,
	});
	var xMinCurveText = view.text({
		width:1, data:["xMin"], font: "Helvetica", style: "normal"
	});
	var xMinCurveTextView = view.label({
		text: xMinCurveText, points: xMinCurveData,
		size: 10, color: "lightgreen", outline: 0, offset: [-20,-40], zIndex: 3, visible: true
	});
	
	
	var xMaxCurveData = view.interval({
		axis: 3, channels: 3, width: 64,
	});
	var xMaxCurveView = view.line({
		points: xMaxCurveData,
		color: "lightgreen", width: 16, visible: true,
	});
	var xMaxCurveText = view.text({
		width:1, data:["xMax"], font: "Helvetica", style: "normal"
	});
	var xMaxCurveTextView = view.label({
		text: xMaxCurveText, points: xMaxCurveData,
		size: 10, color: "lightgreen", outline: 0, offset: [-20,-40], zIndex: 3, visible: true
	});
	
	
	var yMinCurveData = view.interval({
		axis: 1, channels: 3, width: 64,
	});
	var yMinCurveView = view.line({
		points: yMinCurveData,
		color: "lightpink", width: 16, visible: true,
	});
	var yMinCurveText = view.text({
		width:1, data:["yMin"], font: "Helvetica", style: "normal"
	});
	var yMinCurveTextView = view.label({
		text: yMinCurveText, points: yMinCurveData,
		size: 10, color: "lightpink", outline: 0, offset: [-20,40], zIndex: 3, visible: true
	});
	
	var yMaxCurveData = view.interval({
		axis: 1, channels: 3, width: 64,
	});
	var yMaxCurveView = view.line({
		points: yMaxCurveData,
		color: "lightpink", width: 16, visible: true,
	});
	var yMaxCurveText = view.text({
		width:1, data:["yMax"], font: "Helvetica", style: "normal"
	});
	var yMaxCurveTextView = view.label({
		text: yMaxCurveText, points: yMaxCurveData,
		size: 10, color: "lightpink", outline: 0, offset: [-20,40], zIndex: 3, visible: true
	});
	
	
	<!-- END OF CURVE (RANGE DOMAIN) DISPLAY  ==================================================== -->
	
	
   
	<!-- START OF CRITICAL PTS CALC  ==================================================== -->
	
	// the function to calculate possible critical points within a set range
	// note this function would return an array of points only
	// it does not result in the points plotted to the graph (yet)
	function critPointsCalc(xMin, xMax, yMin, yMax, f) 
	{	
		 fx = math.derivative(functionText, 'x') ; 
		 fy = math.derivative(functionText, 'y') ; 
		
		var step = 0.01; // density or granularity of search
		var points = [];

		// for every possible x (with increment of "step") within xRange
		for (var x = xMin; x <= xMax; x += step) 
		{	
			// combined with every possible y (with increment of "step") within yRange
			for (var y = yMin; y <= yMax; y += step) 
			{ 
				var z = f(x,y); // calculate the z val of this combination

				let scope = {x:x, y:y}; // to calculate the fx and fy values of this combination
			
				var dzx = fx.evaluate(scope) ;
				var dzdx = Math.round(dzx * 100) / 100; //rounded to remove noise
	
				var dzy = fy.evaluate(scope) ;
				var dzdy = Math.round(dzy * 100) / 100; //rounded to remove noise
				
				var xRound = Math.round(x * 100) / 100;
				var yRound = Math.round(y * 100) / 100;
				var zRound = Math.round(z * 100) / 100;
				
				if (dzdx == 0 && dzdy == 0) {
					points.push( [xRound,zRound,yRound] );
				}
			}
		}
		return points;
	}
	
	<!-- END OF CRITICAL PTS CALC  ==================================================== -->	
	
	
   <!-- START OF CRITICAL PTS DISPLAY  ==================================================== -->
	
	var critPointsDispArray = []; // to transfer the points from critpoint calc for displaying on graph (in the order of x,z,y per index)
	var critPointsLabelArray = []; // to transfer re-indexed x,y points from the above array
	var critPointsClassArray = []; // to store the calculations of crit points classifications

	
	var displayCritPointsFunc = function ()
	{
		// create alert first before calculating the critical points, for better UX
		// since calculations will be quite slow, especially for more complex equations
		// further UX improvements can include a loading/buffer screen while calculating
		alert("Critical points will be calculated upon closing this alert.\n\nThis will take a while.\n\nDO NOT refresh the page or press any other buttons while it's loading as it will slow down the process.");
		
		f = Parser.parse( functionText ).toJSFunction( ['x','y'] );
		
		var fx = math.derivative(functionText, 'x')  ; 
		var fy = math.derivative(functionText, 'y')  ; 
		
		var fxx = math.derivative(fx, 'x');
		var fyy = math.derivative(fy, 'y');
		var fxy = math.derivative(fx, 'y');
		
		// emptying the array first for every time the function is called
		// so that there's no lingering from previous equation
		critPointsDispArray = [];

		
		// now we transfer the points values from the calculation
		// for this module, we just calculate the critical points within the boundary R
		critPointsDispArray = critPointsCalc( lowerXRange, upperXRange, lowerYRange, upperYRange, f);
		
		critPointData.set( "width", critPointsDispArray.length);
		critPointData.set( "data", critPointsDispArray); // remember that it's x,z,y for plotting the points with Mathbox
		
		// now we are re-indexing the critPointsDispArray
		// for labeling purposes, we want to display the point locations in their proper format x,y (z is not needed)
		critPointsLabelArray = [];
		critPointsClassArray = [];
		
		for (var m = 0; m < critPointsDispArray.length; m++)
		{
			var xPoint = critPointsDispArray[m][0];
			var yPoint = critPointsDispArray[m][2];  // remember that y point is stored in [2] index
			
			critPointsLabelArray.push( [ "(" + xPoint + "," + yPoint + ")" ] );
			
			
			var fxxVal = fxx.evaluate({x: xPoint, y: yPoint}) ;
			var fxx0 = Math.round(fxxVal * 100) / 100;

			var fyyVal = fyy.evaluate({x: xPoint, y: yPoint}) ;
			var fyy0 = Math.round(fyyVal * 100) / 100;

			var fxyVal = fxy.evaluate({x: xPoint, y: yPoint}) ;
			var fxy0 = Math.round(fxyVal * 100) / 100;

			var H = fxx0 * fyy0 - Math.pow(fxy0,2);

			if (H == 0) {
				critPointsClassArray.push( "undefined" );
			} else if (H < 0) {
				critPointsClassArray.push( "saddle point" );
				
			} else if (H > 0) {
				if (fxx0 < 0) {
					critPointsClassArray.push( "maxima" );

				} else if (fxx0 > 0) {
					critPointsClassArray.push( "minima" );

				}
			}	
		}
		
		critPointLocText.set( "width", critPointsLabelArray.length);

		critPointClassText.set( "width", critPointsClassArray.length);

		globalMaximaArray = [];
		globalMaximaData.set("data",[globalMaximaArray]);
		
		globalMinimaArray = [];
		globalMinimaData.set("data",[globalMinimaArray]);
		
		globalMaximaLocArray = [];
		globalMinimaLocArray = [];
		
		
		optimaArray = [];
		optimaArray = OptimaCalcFunc(lowerXRange, upperXRange, lowerYRange, upperYRange, f);
		
		OptimaDisplayFunc();

	}
	
	var critPointData = view.array({
		width: critPointsDispArray.length, //the amt of points to be displayed
		channels: 3,
		data: [ critPointsDispArray ],
	});
	
	var critPointVisible = false;
	
	var critPointView = view.point({
		size: 30, color: "white", 
		points:critPointData, zIndex: 1,
		visible: critPointVisible
	});
	
	var critPointLocVisible = false;
	
	var critPointLocText = view.text({
		width: critPointsLabelArray.length,
		expr: function(emit,i,t){
			var str = critPointsLabelArray[i];
			emit(str);
			i++;
		},
		font: "Helvetica", style: "normal" 
	});
	var critPointLocLabel = view.label({
		text: critPointLocText, points: critPointData,
		size: 14, color: "white", outline: 0, offset: [0,-24], zIndex: 2,
		visible: critPointLocVisible,
	});
	
	var critPointClassVisible = false;
	
	var critPointClassText = view.text({
		width: critPointsClassArray.length,
		expr: function(emit,i,t){
			var str = critPointsClassArray[i];
			emit(str);
			i++;
		},
		font: "Helvetica", weight: "bold", style: "normal" 
	});
	var critPointClassLabel = view.label({
		text: critPointClassText, points: critPointData,
		size: 14, color: "white", outline: 0, offset: [0,24], zIndex: 2,
		visible: critPointClassVisible,
	});
	
	
	<!-- END OF CRITICAL PTS DISPLAY  ==================================================== -->
	
	
	<!-- START OF GLOBAL OPTIMA CALCULATIONS ===================================================== -->
	// for this function, we actually just need to find the max Z value and min Z value of a function within the set Range
	// there is no need to tie it to critical points calculations, we just use Javascript min & max array calculations
	
	// first we find possible z values of every x & y within the Range
	var OptimaCalcFunc = function(xMin, xMax, yMin, yMax, f)
	{
		var points = [];
		var step = 1;
	
		for (var x=xMin; x <= xMax; x += step)
		{
			for (var y=yMin; y <= yMax; y += step)
			{
				var z = f(x,y);
				points.push([x,z,y]);
			}
		}
		return points;
	}
	
	var optimaArray = [];
	
	var globalMaximaArray = [];
	var globalMinimaArray = [];
	
	var globalMaximaLocArray = [];
	var globalMinimaLocArray = [];
	
	var OptimaDisplayFunc = function()
	{
		
		//we run through the z values in optimaArray first
		var zPointsArray = [];
		for (var u = 0; u < optimaArray.length; u++) 
		{
			zPointsArray.push(optimaArray[u][1]);
		}
		
		//then we find what is the biggest Z value and the smallest Z value
		var max = Math.max(...zPointsArray);
		var min = Math.min(...zPointsArray);
			
		for (var v = 0; v < optimaArray.length; v++) 
		{	
			var globalX = Math.round(optimaArray[v][0] * 100) / 100;
			var globalY = Math.round(optimaArray[v][2] * 100) / 100;
			
			if (optimaArray[v][1] == max)
			{
				globalMaximaArray.push(optimaArray[v]);
				globalMaximaLocArray.push([ "(" + globalX + "," + globalY + ")" ]);
			}
			if (optimaArray[v][1] == min)
			{
				globalMinimaArray.push(optimaArray[v]);
				globalMinimaLocArray.push([ "(" + globalX + "," + globalY + ")" ]);
			}
		}
		
		globalMaximaData.set("width",globalMaximaArray.length);
		globalMaximaData.set("data",globalMaximaArray);
		
		globalMaximaText.set("width",globalMaximaArray.length);
		globalMaximaLocText.set("width",globalMaximaArray.length);
		
		
		globalMinimaData.set("width",globalMinimaArray.length);
		globalMinimaData.set("data",globalMinimaArray);
		
		globalMinimaText.set("width",globalMinimaArray.length);
		globalMinimaLocText.set("width",globalMinimaArray.length);
		
	}
	
	var globalOptimaVisible = false;
	
	var globalMaximaData = view.array({
		width: globalMaximaArray.length, //the amt of points to be displayed
		channels: 3,
		data: [ globalMaximaArray ],
	});
	
	var globalMaximaView = view.point({
		size: 30, color: "red", 
		points:globalMaximaData, zIndex: 1,
		visible: globalOptimaVisible
	});
	
	var globalMaximaText = view.text({
		width: globalMaximaArray.length,
		expr: function(emit,i,t){
			var str = "Global Maxima";
			emit(str);
			i++;
		},
		font: "Helvetica", weight: "bold", style: "normal" 
	});
	var globalMaximaLabel = view.label({
		text: globalMaximaText, points: globalMaximaData,
		size: 14, color: "red", outline: 0, offset: [0,24], zIndex: 2,
		visible: globalOptimaVisible,
	});
	var globalMaximaLocText = view.text({
		width: globalMaximaArray.length,
		expr: function(emit,i,t){
			var str = globalMaximaLocArray[i];
			emit(str);
			i++;
		},
		font: "Helvetica", weight: "bold", style: "normal" 
	});
	var globalMaximaLocLabel = view.label({
		text: globalMaximaLocText, points: globalMaximaData,
		size: 14, color: "red", outline: 0, offset: [0,-24], zIndex: 2,
		visible: globalOptimaVisible,
	});
	
	
	var globalMinimaData = view.array({
		width: globalMinimaArray.length, //the amt of points to be displayed
		channels: 3,
		data: [ globalMinimaArray ],
	});
	
	var globalMinimaView = view.point({
		size: 30, color: "gold", 
		points:globalMinimaData, zIndex: 1,
		visible: globalOptimaVisible
	});
	
	var globalMinimaText = view.text({
		width: globalMinimaArray.length,
		expr: function(emit,i,t){
			var str = "Global Minima";
			emit(str);
			i++;
		},
		font: "Helvetica", weight: "bold", style: "normal" 
	});
	var globalMinimaLabel = view.label({
		text: globalMinimaText, points: globalMinimaData,
		size: 14, color: "gold", outline: 0, offset: [0,24], zIndex: 2,
		visible: globalOptimaVisible,
	});
	var globalMinimaLocText = view.text({
		width: globalMinimaArray.length,
		expr: function(emit,i,t){
			var str = globalMinimaLocArray[i];
			emit(str);
			i++;
		},
		font: "Helvetica", weight: "bold", style: "normal" 
	});
	var globalMinimaLocLabel = view.label({
		text: globalMinimaLocText, points: globalMinimaData,
		size: 14, color: "gold", outline: 0, offset: [0,-24], zIndex: 2,
		visible: globalOptimaVisible,
	});
	
	
	<!-- END OF GLOBAL OPTIMA CALCULATIONS ===================================================== -->
	
	
	<!-- START OF TRACE POINT SETTING ===================================================== -->

	var traceX = 0, traceY = 0, traceZ; //x0,y0,z0

	var displayTraceFunc = function ()
	{
		f = Parser.parse( functionText ).toJSFunction( ['x','y'] );

		traceZ = f(traceX, traceY); // z0 = f(x0,y0)
		tracePointData.set("data", [ [traceX, traceZ, traceY] ] );
		
		var traceXDisp = Math.round(traceX * 100) / 100;
		var traceYDisp = Math.round(traceY * 100) / 100;
		var traceZDisp = Math.round(traceZ * 100) / 100;
		traceText.set( "data", ["(" + traceXDisp + " , " + traceYDisp + " , " + traceZDisp + ")"] );
		traceTextView.set("visible", traceVisible);

	}

	// plot a point on the graph.

	// use data: instead of expr: because it is a single value, no need to calculate via expr.
	// actual value of data set later (requires zFunction to be parsed)
	var tracePointData = view.array({
		width: 3, channels: 3,
		data: [ [1,2,3] ],
    });

	// make point display optional (default is false)
	var traceVisible = false;
	var tracePointView = view.point( {size: 30, color: "cyan", points:tracePointData, visible: traceVisible, zIndex: 1} );

	
	var traceText = view.text( {width:1, data:["(0,0,0)"], font: "Helvetica", weight: "bold", style: "normal"} );
	var traceTextView = view.label( {text: traceText, points: tracePointData,
      size: 14, color: "cyan", outline: 0, offset: [120,0], zIndex: 3, visible: traceVisible} );
	
	<!-- END OF TRACE POINT SETTING ===================================================== -->


   
	<!-- START OF GUI SETTING ===================================================== -->
	// to control the parameters for displaying the graph

	var gui = new dat.GUI();

	gui.add( this, 'functionText' ).name('z = f(x,y) = ');
	gui.add( this, 'displayGraphFunc' ).name("Update Graph");
	
	var optimaFolder = gui.addFolder( "Range (Domain)" );
	
	var xRangeFolder = optimaFolder.addFolder( "xMin <= R <= xMax" );
	xRangeFolder.add(this, 'lowerXRange' ).min(xMin).max(-0.01).step(0.1).name('xMin = ').onChange( displayRangeFunc );
	xRangeFolder.add(this, 'upperXRange' ).min(0.01).max(xMax).step(0.1).name('xMax = ').onChange( displayRangeFunc );

	
	var yRangeFolder = optimaFolder.addFolder( "yMin <= R <= yMax" );
	yRangeFolder.add(this, 'lowerYRange' ).min(yMin).max(-0.01).step(0.1).name('yMin = ').onChange( displayRangeFunc );
	yRangeFolder.add(this, 'upperYRange' ).min(0.01).max(yMax).step(0.1).name('yMax = ').onChange( displayRangeFunc );

	
	
	var cpFolderGUI = gui.addFolder( "Critical Points within Range (calculate first!)" );
	
	cpFolderGUI.add( this, 'displayCritPointsFunc' ).name("Calculate");
	
	cpFolderGUI.add( this, "critPointVisible" ).name("Show points").onChange(
		function()
		{
			critPointView.set("visible", critPointVisible);
		}
	);
	
	cpFolderGUI.add( this, "critPointLocVisible" ).name("Locations (x,y)").onChange(
		function()
		{
			critPointLocLabel.set("visible", critPointLocVisible);
		}
	);
	
	cpFolderGUI.add( this, "critPointClassVisible" ).name("Classifications").onChange(
		function()
		{
			critPointClassLabel.set("visible", critPointClassVisible);
		}
	);
	
	cpFolderGUI.add( this, "globalOptimaVisible" ).name("Global Optima").onChange(
		function()
		{
			globalMaximaView.set("visible", globalOptimaVisible);
			globalMaximaLabel.set("visible", globalOptimaVisible);
			globalMaximaLocLabel.set("visible", globalOptimaVisible);
			
			globalMinimaView.set("visible", globalOptimaVisible);
			globalMinimaLabel.set("visible", globalOptimaVisible);
			globalMinimaLocLabel.set("visible", globalOptimaVisible);
		}
	);
	
	var traceFolderGUI = gui.addFolder( "Trace (x0,y0) point on graph");
	
	traceFolderGUI.add( this, "traceVisible" ).name("Trace(x0,y0)").onChange(
		function()
		{
			tracePointView.set("visible", traceVisible);
			traceTextView.set("visible", traceVisible);
		}
	);
	var xPointGUI = traceFolderGUI.add( this, 'traceX' ).min(xMin).max(xMax).step(0.01).name('x0 = ');
	xPointGUI.onChange( displayTraceFunc );
	var yPointGUI = traceFolderGUI.add( this, 'traceY' ).min(yMin).max(yMax).step(0.01).name('y0 = ');
	yPointGUI.onChange( displayTraceFunc );
	
	
	<!-- ON LOAD -->
	// Display the default graph on load, otherwise nothing will be displayed
	displayGraphFunc();
	
	


</script>
</body>
</html>